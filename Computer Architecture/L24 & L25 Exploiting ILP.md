- If only 1 instruction issued every clock cycle, CPI >= 1
	- Ideal CPI is 1

To achieve CPI <= 1, issue multiple instructions every clock cycle

**Multiple Issue processors can be classified into:**
- Compiler: statically scheduled super-scalar processors
	- In order execution if they are statically scheduled
- Runtime: Dynamically scheduled super-scalar processors
	- Out of order execution if they are dynamically scheduled
- Compiler: Very Long Instruction Word (VLIW) processors
	- Issues fixed number of instructions formatted either as one large instruction or a fixed instruction package (bundle) with parallelism among instructions explicitly indicated by instruction
	- Similar to VLIW --> EPIC

## Multiple Issue Processors

![[Pasted image 20251024074211.png]]

- Superscalar: Multiple instructions that can be issued at the same time
	- Static: By compiler --> HW to detect all dependences --> Execute in order
	- Dynamic: Tomasulo's is an example --> out-of-order --> none without speculation
	- Speculative: Out of order execution with speculation --> Latest intel/amd chips
- VLIW --> Anything larger than 2 instructions is very large, 2 is "large instruction word". Compiler is the one that looks at all dependences --> Hazards by compiler --> Used in signal processing
	- Ex: Loop unrolling is good example
- EPIC --> Similar to VLIW. Either are not super common

Why is static superscalar with dynamic issue structure?:
	Similar to VLIW, compiler determines sequence of instructions.
	--> Static issue: whatever order instruction comes in, issue
	--> Dynamic: HW defines when to issue instructions
	**Only issuing one instruction that comes out. If no hazards, it can start issuing new instructions**
		In VLIW, static issue because instructions issued are fixed

### VLIW Processors

- Compiler packages instructions, then they could be executed in parallel
	- If not independent, it can put a NO-OP in the instruction bundle

- Package multiple operations in one instruction
- Example:
	- One integer instruction (or branch)
	- Two independent FP operations
	- Two independent memory references
- Need enough parallelism in code to fill available slots

- Each instruction has explicit coding for multiple operations
	- "packet"
- Trade-off instruction space for simple decoding
- **All Operations in each instruction execute in parallel**
- Need compiling technique that schedules across several branches
- Assume compiler can figure out parallelism and assume correct

### Loop Unrolling in VLIW

- Recall fld to fadd needs 1 cycle in between, and add to store 2 cycles
- Ex: Unrolling 7 times:
- ![[Pasted image 20251024081738.png]]

### Problems with 1st gen VLIW

- Increase code size
	- Very long unroll to generate enough operations in straight line
	- Whenever VLIW instructions not full, unused functional units translate to wasted bits in instruction encoding
- Operated in lock-step. No hazard detection HW
	- No hardware checking
	- Stall in any functional unit pipeline caused entire processor and all operations of the instruction to stall, since all functional units need to be synchronized
	- Caches hard to predict
- Binary code compatibility
	- Need different binary to use architecture
	- Pure VLIW -> different numbers of functional units and unit latencies require different versions of code

## Dynamically-Scheduled Superscalar

